**추천 시스템과 사용한 레이어를 추적하는데 사용할 그래프 DB**

# Neo4j

Neo4j는 그래프 데이터베이스로, 데이터 간의 복잡한 연결 관계를 표현하고 탐색할 수 있다.

## 1. 기본 개념

### 노드(Node)
엔티티(예: 사용자, 음악, 프로젝트 등)를 표현한다.  
노드는 레이블(Label)을 통해 유형을 구분할 수 있으며, 각 노드는 이름, 아이디 등의 속성(Property)을 가질 수 있다.

### 관계(Relationship)
노드들 사이의 연결을 나타내며, 방향성을 가진다.  
관계 역시 속성(예: 생성 날짜, 강도 등)을 가질 수 있다.  
예를 들어, User 노드와 Music 노드를 LIKES 관계로 연결할 수 있다.

### 속성(Property)
노드와 관계에 붙이는 키-값 쌍으로, 구체적인 정보를 저장한다.

### Cypher Query Language
Neo4j의 데이터 질의를 위한 선언적 쿼리 언어이다.  
SQL과 유사하지만, 그래프 데이터에 특화된 패턴 매칭 방식을 사용한다.  
예를 들어, 다음과 같은 쿼리를 통해 노드를 생성, 조회, 관계를 생성할 수 있다.

- **노드 생성**
  ```cypher
  CREATE (n:Music {title: "Imagine", artist: "John Lennon"})
  ```

- **노드 생성**
  ```cypher
  CREATE (n:Music {title: "Imagine", artist: "John Lennon"})
  ```

- **노드 조회**

    ```cypher
    MATCH (n:Music)
    RETURN n
    ```

- **관계 생성**
    ```cypher
    MATCH (u:User {name: "Alice"}), (m:Music {title: "Imagine"})
    CREATE (u)-[:LIKES]->(m)
    ```

## 2. 추천 시스템 이론
그래프 기반 추천 시스템은 그래프의 연결 구조를 활용하여 아이템(음원 등)과 사용자의 관련성을 파악하고 유의미한 연관 경로를 찾아내어 추천을 제공하는 시스템이다. 전통적인 추천 기법을 그래프에서 구현하면 다음과 같은 접근 방식들이 있다.

### 협업 필터링 (Collaborative Filtering)
사용자들의 행동 패턴을 그래프 연결로 파악하여 비슷한 취향을 가진 사용자를 찾고 아이템을 추천한다.
예를 들어, 사용자 A와 B가 모두 어떤 음악을 좋아했다면 그래프 상에서 사용자 A 노드와 B 노드가 공통으로 좋아요한 음악 노드를 통해 간접적으로 연결된다.
이러한 공통 아이템을 통한 연결로 A와 B가 유사한 취향을 가졌다고 볼 수 있으며, B가 좋아하지만 A가 아직 접하지 않은 다른 음악을 추천할 수 있다.
이는 여러 사람의 선호를 종합해 "나와 비슷한 취향의 다른 사용자가 좋아하는 것을 나에게도 추천"하는 방식으로, 아마존 상품 추천이나 넷플릭스 영화 추천 등에서 사용되는 접근이다.

### 콘텐츠 기반 필터링 (Content-Based Filtering)
아이템 자체의 속성이나 태그 정보를 그래프로 활용하는 방법이다.
음악의 장르, 분위기 태그, 아티스트 등의 콘텐츠 특성 노드를 연결하여, 사용자가 선호한 음악과 유사한 속성을 가진 다른 음악을 추천한다.
예를 들어 사용자가 락(rock) 장르의 음악을 여러 곡 즐겨 들었다면, 그래프에서 그 사용자가 좋아한 음악들이 공통적으로 연결된 Genre:Rock 태그 노드를 찾아내고, 그 태그에 연결된 다른 음악 노드들을 추천하는 방식이다.
이렇게 하면 사용자의 기존 취향(콘텐츠 특징)에 부합하는 새로운 음악을 제안할 수 있다.
콘텐츠 기반 필터링은 사용자의 과거 시청/청취 이력의 아이템 특징에 초점을 맞추기 때문에, 새로운 사용자라도 선호 태그만 파악되면 초기 추천을 제공하는 데 유용하다.

### 경로 탐색 기반 추천 (Path-Based Recommendation)
그래프의 다단계 경로를 탐색하여 직접적이지는 않지만 연결된 관계망 속에서 추천 단서를 찾는 방법이다.
예를 들어, 사용자와 아이템 사이에 여러 종류의 노드(프로젝트, 친구 사용자, 태그 등)가 끼어있는 다중 홉(hop) 경로를 탐색함으로써 추천을 생성할 수 있다.
한 사용자가 참여한 프로젝트에 포함된 음악을 다른 사용자가 좋아했다면, 그 다른 사용자가 선호하는 또 다른 음악을 첫 사용자에게 추천하는 식으로 연결의 연결을 따라간다.
이때 그래프 알고리즘을 활용하면 방대한 경로 중에서도 중요한 연결을 찾을 수 있는데, Personalized PageRank 같은 알고리즘은 특정 노드(사용자)를 기준으로 무작위 워크를 수행해 연결 중심성이 높은 아이템을 확률적으로 선정하여 추천에 활용할 수 있다.
PageRank는 원래 웹 페이지 랭킹을 위한 알고리즘이지만, 소셜 그래프나 추천 그래프에 응용하여 "이 사용자가 관여하는 서브그래프에서 중심성이 높은 (즉, 이웃으로부터 인기도가 높은) 음악"을 찾는 식으로 개인화 추천에 응용될 수 있다.
이처럼 경로 탐색 기반 접근은 협업 필터링이나 콘텐츠 필터링으로는 포착하기 힘든 다양한 연관성을 발견해줄 수 있다.
그래프 데이터베이스를 활용한 추천 시스템의 대표 사례로 Neo4j 영화 추천 예제를 들 수 있다.
영화 추천 도메인에서 사람(Person)과 영화(Movie) 노드를 ACTED_IN 등의 관계로 연결한 그래프를 생각해보면, 한 배우의 공동 출연자(co-actor)를 찾고 다시 그 공동 출연자의 다른 영화까지 탐색하여 "함께 작업한 적은 없지만 두 단계를 통해 연결되는 배우"를 추천하는 식의 쿼리를 Cypher로 구현할 수 있다.
이러한 두 단계 연결은 사용자-아이템 추천으로 치환하면 "A 사용자가 좋아한 아이템을 B 사용자도 좋아했고, B가 좋아한 다른 아이템 C"를 A에게 추천하는 형태와 같다.
실제로 Neo4j는 영화 추천 예제에서 Tom Hanks와 함께 작업하지 않았지만 두 단계 이웃으로 연결된 배우들을 추천하는 쿼리 예시를 보여주며, 그래프에서 경로 길이를 늘려 탐색함으로써 새로운 추천을 만들 수 있음을 시연한다.
이처럼 그래프를 이용하면 데이터 간의 복잡한 연결고리를 자연스럽게 탐색하여 추천에 활용할 수 있다.

## 3. 그래프 DB의 장단점
그래프 데이터베이스는 데이터 간의 복잡한 관계를 효과적으로 표현하고 탐색하는 데 강점이 있다. 그러나 아직 널리 알려지지 않은 이유는 다음과 같다.

1. **학습 곡선이 가파르다.**  
   기존 관계형 데이터베이스에 익숙한 개발자들이 새로운 데이터 모델과 쿼리 언어(예: Cypher 등)를 배우는 데 부담이 있다.

2. **특정 도메인에 특화되어 있다.**  
   소셜 네트워크, 추천 시스템, 사기 탐지 등 관계 분석이 중요한 분야에서 주로 사용되며, 일반적인 빅데이터 처리나 AI 추천 시스템에서는 RDBMS나 기존 빅데이터 솔루션으로 충분히 대응할 수 있다.

3. **생태계와 도구의 성숙도가 상대적으로 낮다.**  
   관계형 데이터베이스는 오랜 시간 동안 발전하여 안정적인 운영 및 관리 도구가 많지만, 그래프 데이터베이스는 아직 도입 사례와 지원 도구가 제한적이다.

또한, 노드가 많아지더라도 그래프 데이터베이스는 인접 노드를 직접 참조하는 인덱스 프리 인접성(Index-Free Adjacency) 방식을 사용하기 때문에 전체 노드 수에 비례해 성능이 저하되지 않는다. 다만, 특정 노드에 과도하게 많은 관계(팬아웃)가 몰릴 경우 성능 저하가 발생할 수 있으므로, 데이터 모델링과 최적화가 중요하다.

## 4. 팬아웃 해결하기
음악 데이터가 급증하면서 하나의 'pop' 태그 노드에 너무 많은 음악 노드가 연결되면, 조회 시 지나치게 많은 관계(팬아웃) 때문에 성능 저하가 발생할 수 있다. 이러한 문제는 그래프 데이터베이스에서 흔히 ‘슈퍼노드(supernode)’ 문제라고 불린다.

이를 해결하는 방법으로는 다음과 같은 전략들이 있다.

1. **태그를 속성으로 저장하기**  
   만약 태그 정보가 단순 조회나 필터링 용도로만 사용된다면, 별도의 태그 노드 대신 각 음악 노드의 속성(property)으로 저장하는 방법이 있다. 이렇게 하면 한 태그 노드에 모든 음악을 연결하는 대신, 음악 노드 자체에 ‘pop’이라는 값이 포함되어 있어 인덱싱이나 필터링을 통해 빠르게 검색할 수 있다.

2. **태그 노드 분할 및 하위 그룹 도입**  
   ‘pop’과 같이 팬아웃이 매우 큰 태그 노드는 하위 카테고리나 추가 기준(예: 연도, 지역, 세부 장르 등)을 활용해 여러 개의 태그 노드로 분할할 수 있다. 예를 들어 “pop” 태그를 “pop_2020”, “pop_2021” 등으로 분리하면 각 노드에 연결되는 음악 수가 줄어들어 쿼리 성능이 개선된다.

3. **중간 그룹 노드 도입**  
   하나의 태그 노드와 음악 노드 사이에 중간 노드를 추가해 연결을 분산시킬 수 있다. 예를 들어, “pop” 태그와 관련된 음악들을 주제별 또는 서브카테고리별로 그룹화한 중간 노드를 도입하면, 한 번에 조회해야 하는 연결 수가 줄어들어 성능 부담을 낮출 수 있다.

4. **쿼리 최적화 및 제한 적용**  
   팬아웃이 큰 노드에 대해 쿼리를 작성할 때, 필요한 경우 LIMIT이나 추가 필터 조건을 적용해 불필요한 노드 탐색을 제한하고, 인덱스 또는 캐싱 기법을 활용해 조회 속도를 개선할 수 있다.

이와 같이 서비스의 데이터 특성과 사용 패턴에 맞춰 모델을 조정하면, 팬아웃 문제를 완화하고 전체 시스템의 성능을 최적화할 수 있다.
