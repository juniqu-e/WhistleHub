# Cypher 쿼리
- 그래프 데이터베이스의 기본 구성 요소는 노드(Node)와 관계(Relationship)
- 노드는 그래프 데이터베이스의 데이터 레코드를 나타내며, 관계는 이러한 노드 사이의 연결을 정의
- 각 노드와 관계는 속성(Property)을 가질 수 있으며, 노드는 레이블(Label)을 통해 분류
- 복잡한 연결 관계를 가진 데이터를 효과적으로 표현하고 탐색
## 그래프 데이터베이스의 핵심 요소
### 노드(Node)
- 그래프 데이터베이스의 기본 데이터 레코드
- 관계형 데이터베이스의 행(row)과 유사한 개념이지만, 다른 노드와의 관계를 직접적으로 표현할 수 있다는 점이 큰 차이
### 레이블(Label)
- 노드의 집합을 정의
- 레이블을 통해 같은 특성을 가진 노드들을 그룹화하여 도메인을 형성할 수 있음
### 관계(Relationship)
- 노드 사이의 연결을 정의
- 항상 방향성을 가지며, 두 노드 간에 여러 관계가 존재할 수 있음
### 속성(Property)
- 노드와 관계에 부여되는 이름-값 쌍
- 노드와 관계에 추가적인 정보를 저장

## Cypher 쿼리 기초 문법
-  여러 절(clause)을 연결하는 방식으로 쿼리를 구성
-  중간 결과를 서로 연결하며, 각 절의 매칭 변수는 다음 절이 작동하는 컨텍스트
## 주요 Cypher 키워드
### MATCH
- 데이터베이스에서 노드, 관계, 레이블, 속성 또는 패턴을 검색하는 데 사용.
- SQL의 SELECT와 유사한 역할을 하지만, 그래프 패턴을 지정하여 검색할 수 있다는 점이 큰 차이
- 그래프에서 데이터를 가져오는 가장 일반적인 방법
### RETURN
- 쿼리 결과로 반환할 값을 지정
- 노드, 관계, 속성 또는 패턴을 반환하도록 지시
- RETURN을 반드시 사용해야 함, 생략할 경우 구문 오류가 발생.
### WHERE
- MATCH, OPTIONAL MATCH 등의 일부로 사용되며, 패턴에 제약 조건을 추가하거나 중간 결과를 필터링하는 역할
### CREATE
- 노드와 관계를 생성하는 데 사용
- 속성과 레이블을 지정하여 새로운 데이터를 그래프에 추가

## 노드와 관계 조작하기
### 노드 생성
- 노드 생성 시 레이블과 속성을 함께 지정할 수 있음
```
CREATE (p:Person {name: '테스트'})
```
### 노드 조회
- 'Person' 레이블을 가진 노드 중에서 name 속성이 '테스트'인 노드를 찾아 반환
```
MATCH (p:Person{name:'테스트'})
RETURN p
-- 모든 Person 노드 조회회
MATCH (p:Person)
RETURN p
```
### 관계 생성
- 두 노드를 찾은 다음, CREATE 문을 사용하여 관계를 설정
```
MATCH (a:Person {name:'테스트'}), (b:Person{name: 'Dan'})
CREATE (a)-[r:LIKES]->(b)
RETURN r
```
### 노드와 관계 삭제
- 노드를 삭제하기 전에는 해당 노드와 연결된 모든 관계를 먼저 제거
```
-- 관계 삭제
MATCH (p:Person)-[r:LIKES]->(Person{name:'Dan'}) DELETE r

-- 노드 삭제
MATCH (p:Person {name: 'Dan'}) DELETE p
```
### 고급 쿼리 기법
#### 패턴 매칭을 통한 복잡한 관계 탐색
```
MATCH (john {name: 'John'})-[:FRIEND]->()-[:FRIEND]->(fof)
RETURN john.name AS me, fof.name AS `two hops`
```
- 'John'이라는 이름을 가진 노드에서 시작하여 'FRIEND' 관계를 두 번 거친 노드를 찾는다. 
- AS 키워드를 사용하여 결과 열의 이름을 변경할 수도 있음
#### 조건부 패턴과 선택적 매칭
- OPTIONAL MATCH를 사용하면 패턴이 존재하지 않을 경우에도 NULL 값을 반환하여 쿼리 결과를 유지
```
MATCH (p:Person)
WHERE p.name STARTS WITH 'J'
OPTIONAL MATCH (p)-[:WORKS_FOR]-(other:Company)
RETURN p.name, other.name
```
- 이름이 'J'로 시작하는 모든 Person 노드를 찾고, 해당 사람이 일하는 회사 정보가 있다면 함께 반환
### 집계 함수 사용
- SQL과 달리 그룹화 키를 명시적으로 지정할 필요가 없다
```
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
RETURN p.name, collect(friend.name) AS friend
```
- 각 사람과 그 사람의 친구 목록을 반환
- collect() 함수는 여러 값을 배열로 모아주는 역할

## 제약조건 최적화
- 유니크 제약 추가
```
CREATE CONSTRAINT FOR (n:Person) REQUIRE n.name IS UNIQUE
```
## 결과 제한과 정렬
- 결과의 수를 제한하거나 특정 기준으로 정렬하여 쿼리 결과를 관리
```
MATCH (m:Movie) 
WHERE m.released > 2000 
RETURN m 
LIMIT 5
```
- 2000년 이후에 출시된 영화 중 5개만 반환


# LangChain4j 사용 가이드

LangChain4j는 Java 환경에서 대규모 언어 모델(LLM)을 쉽게 통합하고 활용할 수 있게 해주는 라이브러리입니다. 이 가이드에서는 LangChain4j의 기본 개념부터 고급 기능까지 상세히 알아보겠습니다.

## LangChain4j 소개

- LangChain4j는 Python 환경의 LangChain 프로젝트를 Java로 구현한 버전. 
- 다양한 LLM 제공자(OpenAI, Google Vertex AI 등)와 임베딩 저장소를 통합적인 API로 제공하여 개발자가 특정 공급업체의 API를 학습할 필요 없이 쉽게 전환할 수 있도록 함.

### 주요 특징

- 통합 API: 15개 이상의 LLM 제공자와 15개 이상의 임베딩 저장소를 지원
- 포괄적 도구 상자: 프롬프트 템플릿, 채팅 메모리 관리, 함수 호출 등의 저수준 기능부터 에이전트와 RAG 같은 고수준 패턴까지 제공
- 다양한 예제: 다양한 LLM 기반 애플리케이션 구축 방법을 보여주는 풍부한 예제
- Java 8 이상 지원: 모던 Java 기능도 활용 가능

## 설치 및 환경 설정

### Maven 의존성 추가

```
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j</artifactId>
    <version>0.36.2</version>
</dependency>

<!-- OpenAI 모델 사용 시 -->
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-open-ai</artifactId>
    <version>0.36.2</version>
</dependency>
```

### Gradle 의존성 추가

```
implementation 'dev.langchain4j:langchain4j:0.36.2'
implementation 'dev.langchain4j:langchain4j-open-ai:0.36.2'
```

### Micronaut과 함께 사용하기 위한 의존성

```
<dependency>
    <groupId>io.micronaut.langchain4j</groupId>
    <artifactId>micronaut-langchain4j-core</artifactId>
    <version>0.0.1</version>
</dependency>
<dependency>
    <groupId>io.micronaut.langchain4j</groupId>
    <artifactId>micronaut-langchain4j-openai</artifactId>
    <version>0.0.1</version>
</dependency>
```

### API 키 설정 (예: OpenAI)

YAML 파일에 API 키 설정:

```
langchain4j:
  open-ai:
    api-key: ${OPENAI_API_KEY}
```

## 기본 사용법

### Hello World 예제

가장 기본적인 LLM 호출 예제:

```
// LLM 모델 생성
ChatLanguageModel chatLanguageModel = OpenAiChatModel.builder()
    .apiKey("your-api-key")
    .build();

// 모델에 텍스트 전송 및 응답 출력
String response = chatLanguageModel.generate("안녕하세요");
System.out.println(response);
```

### 프롬프트 템플릿 사용하기

템플릿 변수를 활용하여 동적으로 프롬프트를 생성할 수 있음음:

```
// 프롬프트 템플릿 생성
PromptTemplate template = PromptTemplate.from("단어 {{word}}를 번역하세요.");

// 변수 값 설정
Map<String, Object> vars = Map.of("word", "안녕하세요");

// 템플릿에 변수 적용
String prompt = template.apply(vars);

// 모델에 전송
String result = chatLanguageModel.generate(prompt);
System.out.println(result);
```

### 레시피 생성 예제

복잡한 프롬프트 생성 예제:

```
// 템플릿 생성
PromptTemplate template = PromptTemplate.from("{{dish}} 요리에 대한 레시피를 생성하세요.\n" 
    + "재료: {{ingredients}}");

// 변수 설정
Map<String, Object> vars = Map.of(
    "dish", "오븐 요리", 
    "ingredients", "닭고기, 감자, 양파, 올리브 오일"
);

// 템플릿에 변수 적용
String prompt = template.apply(vars);

// 모델에 전송
String recipe = chatLanguageModel.generate(prompt);
System.out.println(recipe);
```

## 고급 기능

### RAG(검색 증강 생성) 구현

RAG는 사용자 입력을 기반으로 외부 데이터 소스에서 관련 정보를 검색하여 LLM의 응답을 보강:

```
// 임베딩 모델 설정
@Bean
EmbeddingModel ollamaEmbeddingModel() {
    return OllamaEmbeddingModel.builder()
        .baseUrl(baseURL)
        .modelName(embeddingModelName)
        .build();
}

// 데이터 인제스터와 콘텐츠 검색기 설정
@Bean
public EmbeddingStoreIngestor embeddingStoreIngestor(
        EmbeddingModel embeddingModel,
        EmbeddingStore<TextSegment> embeddingStore) {
    return EmbeddingStoreIngestor.builder()
        .embeddingModel(embeddingModel)
        .embeddingStore(embeddingStore)
        .documentSplitter(DocumentSplitters.recursive(500, 0))
        .build();
}

@Bean
public ContentRetriever contentRetriever(
        EmbeddingModel embeddingModel,
        EmbeddingStore<TextSegment> embeddingStore) {
    return ContentRetriever.builder()
        .embeddingModel(embeddingModel)
        .embeddingStore(embeddingStore)
        .maxResults(3)
        .minScore(0.5)
        .build();
}
```

### 구조화된 출력 활용

LLM의 출력을 특정 구조로 받을 수 있음음:

```
// 구조화된 데이터 정의
public record Coach(
    String fullName,
    String nickname,
    String nationality,
    String born,
    String peakRating
) {}

// 데이터 추출기 인터페이스 정의
public interface CoachExtractor {
    @UserMessage("""
        Extract the info for the Coach described below.
        Return strictly only JSON, without any markdown markup surrounding it.
        Here is the document describing the Coach:
        ---
        {{document}}
        ---
        """)
    Coach extractCoach(@V("document") String document);
}

// 사용 예
CoachExtractor extractor = AiServices.builder(CoachExtractor.class)
    .chatLanguageModel(chatModel)
    .build();

Coach coach = extractor.extractCoach(document);
```

## 실제 응용 사례

### 챗봇 만들기

Micronaut과 LangChain4j를 사용한 이사 상담 챗봇 예제:

```
// 챗봇 인터페이스 정의
public interface RelocationAdvisor {
    @SystemMessage("""
        당신은 이사 상담가입니다. 공식적인 어조로 답변하십시오.
        리소스에서 얻은 숫자를 제공하십시오.
        귀하의 지식을 바탕으로 아래 질문에 이관 가능한 국가에 대한 답변을 제공하십시오.
        다음 출처에서만 정보를 가져오십시오:
        - https://www.numbeo.com/cost-of-living/country_result.jsp?country=Spain
        - https://www.numbeo.com/cost-of-living/country_result.jsp?country=Romania
        및 그 하위 페이지. 그런 다음 대답하십시오. 정보가 없는 경우에는 정확한 텍스트 '해당 국가에 대한 정보가 없습니다'라고 답변하십시오.
        """)
    String chat(@UserMessage String question);
}

// 사용 예
RelocationAdvisor advisor = AiServices.builder(RelocationAdvisor.class)
    .chatLanguageModel(chatModel)
    .build();

String response = advisor.chat("스페인의 생활비는 어떤가요?");
```

### URL 자동 번역 및 요약 도구

Kotlin과 LangChain4j를 사용한 URL 컨텐츠 변환 도구:

```
// LangChain4j를 이용하여 HTML을 Text로 변환
val url = params
val htmlDocument: Document = UrlDocumentLoader.load(url, TextDocumentParser())
val textDocument: Document = HtmlTextExtractor().transform(htmlDocument)

// OpenAI GPT-4o LLM 오브젝트 생성
val chatModel: OpenAiChatModel = OpenAiChatModel.builder()
    .apiKey("your-openai-api-key")
    .timeout(Duration.ofSeconds(120))
    .modelName("gpt-4o-2024-05-13")
    .temperature(0.3)
    .topP(0.3)
    .build()

// LLM에게 글 정제와 번역 및 요약 요청
val aiMessage: Response<AiMessage> = chatModel.generate(
    SystemMessage(
        """
        당신은 인터넷 글을 읽고 한국어로 번역해주는 어시스턴트야. 인터넷 글은 아래 context를 참고해서 대답해주고 아래 내용을 준수해야해.
        1. 특정 제품을 홍보하는 등의 광고성 정보 및 헤더, 푸터, 메뉴 정보는 모두 제거하고, 글의 실제 내용만 추출해서 정확히 번역해줘.
        2. 번역 결과는 제목과 각 단락을 적절히 판단하여 Markdown 형식으로 변환해줘.
        3. 번역이 끝난 후에는 전체 글에서 핵심 내용만 한국어로 요약해줘. 아래 형식을 지켜줘.
        
        # 글 원본
        원본 내용
        
        # 글 요약
        요약 내용
        
        context: \\\
        $textDocument
        \\\
        """.trimIndent()
    )
)
```

### Azure OpenAI와 Azure AI Search를 활용한 커스텀 챗봇

Azure 인프라에서 안전하게 격리된 GPT-4o 모델과 Azure AI Search를 연동한 커스텀 챗봇:

```
// 임베딩 생성 및 Azure AI Search에 저장
val embeddings: MutableList<Pair<Embedding, TextSegment>> = mutableListOf()
arrayOf("langchain4j", "langchain4j-embeddings", "langchain4j-examples").forEach { directory ->
    Files.walk(Paths.get(directory)).use { paths ->
        paths.filter {
            Files.isRegularFile(it) && arrayOf(
                "md", "xml", "gradle", "kts", "java", "kt"
            ).contains(it.fileName.toString().substringAfterLast('.', ""))
        }.forEach { path ->
            val document = Document.document(path.toFile().readText())
            val segments = documentSplitter.split(document)
            segments.forEach { segment ->
                embeddings.add(Pair(embeddingModel.embed(segment).content(), segment))
            }
        }
    }
}

// Azure AI Search에 저장
contentRetriever.addAll(embeddings.map { it.first }, embeddings.map { it.second })
```

